cmdhistory=["(board)" "(println board)" "(game)" "(/ 1 3)" "(doquery \:lmh template)" "(m\!)" "(m\! model.core template)" "(use [anglican core])" "(ns model.core\\r\\n  (\:use [anglican core emit runtime]))" "(doquery)" "(m\!)" "(m\! model.core)" "(m\! model.core template)" "stop" "exit" "(sample (normal 1 2))" "(doquery)" "(m\!)" "(ns model.core\\r\\n  (\:use [anglican core runtime emit stat]))" "(doquery)" "(sample (normal 1 2))" "(sample* (normal 1 2))" "(sample (normal 1 2))" "(sample* (normal 1 2))" "(sample* (normal 1 2)\\n         )" "(sample* (normal 1 2))" "(sample* (normal 1 2)\\n         )" "(sample (normal 1 2))" "(turn [[]])" "(turn)" "(turn [])" "(turn 1)" "(m\! model.core turn [])" "(turn [[]])" "(m\! model.core turn [])" "(get-in [[1 2 3][4 5 6][7 8 9]] [1 1])" "(get-in [['blue 'red 'red]['blue 'red 'red]['yellow 'yellow 'blue]] [1 1])" "(get-in [['blue 'red 'red]['blue 'red 'red]['yellow 'yellow 'blue]] [1 3\\n                                                                     ])" "(get-in [['blue 'red 'red]['blue 'red 'red]['yellow 'yellow 'blue]] [1 2])" "(get-in [['blue 'red 'red]['blue 'red 'red]['yellow 'yellow 'blue]] [2 1])" "(doquery)" "(ns model.core\\r\\n  (\:use [anglican core runtime emit stat]))" "(doquery \:lmh turn [['blue 'red 'red]['blue 'red 'red]['yellow 'yellow 'blue]])" "(doquery \:lmh turn test)" "(ns model.core\\r\\n  (\:use [anglican core runtime emit stat]))" "(take 4 (doquery \:lmh turn [['blue 'red 'red]['blue 'red 'red]['yellow 'yellow 'blue]]))" "clear" "(take 4 (doquery \:lmh turn [['blue 'red 'red]['blue 'red 'red]['yellow 'yellow 'blue]]))" "(type (sample (uniform-discrete 0 3)))" "(ns model.core\\r\\n  (\:use [anglican core runtime emit stat]))" "(type (sample (uniform-discrete 0 3)))" "(type (sample* (uniform-discrete 0 3)))" "(println (format \\"position\: %i - %i\\" 3 2))" "(println (format \\"position\: %d - %d\\" 3 2))" "(take 4 (doquery \:lmh turn [['blue 'red 'red]['blue 'red 'red]['yellow 'yellow 'blue]]))" "(take 1 (doquery \:lmh turn [['blue 'red 'red]['blue 'red 'red]['yellow 'yellow 'blue]]))" "(get-in [['blue 'red 'red]['blue 'red 'red]['yellow 'yellow 'blue]] [2 2])" "(format \\"color\: %s\\" (get-in [['blue 'red 'red]['blue 'red 'red]['yellow 'yellow 'blue]] [2 2]))" "(let [position-x (sample* (uniform-discrete 0 3))\\r\\n        position-y (sample* (uniform-discrete 0 3))]\\r\\n    (do\\r\\n      (println (format \\"position\: %d - %d\\" position-x position-y))\\r\\n      (let [color (get-in [['blue 'red 'red]['blue 'red 'red]['yellow 'yellow 'blue]] [position-x position-y])]\\r\\n        (println (format \\"color\: %s\\" color))))))" "(defquery turn [board]\\r\\n  (let [position-x (sample (uniform-discrete 0 3))\\r\\n        position-y (sample (uniform-discrete 0 3))]\\r\\n      (println (format \\"position\: %d - %d\\" position-x position-y))\\r\\n      (let [color (get-in board [position-x position-y])]\\r\\n        (println (format \\"color\: %s\\" color)))))" "(type (sample (uniform-discrete 0 3)))" "(type (sample* (uniform-discrete 0 3)))" "(let [position-x (sample (uniform-discrete 0 3))\\r\\n        position-y (sample (uniform-discrete 0 3))]\\r\\n      (println (format \\"position\: %d - %d\\" position-x position-y)))" "(let [position-x (sample* (uniform-discrete 0 3))\\r\\n           position-y (sample* (uniform-discrete 0 3))]\\r\\n         (println (format \\"position\: %d - %d\\" position-x position-y)))" "(sample* (normal 2 3))" "(ns model.core\\r\\n  (\:use [anglican core runtime emit stat]))" "(assoc (get-in [['blue 'red 'green]['blue 'yellow 'red]['yellow 'yellow 'green]] [2]) 1 'green)" "(ns model.core\\r\\n  (\:use [anglican core runtime emit stat]))" "; Inspired by the snakes that have gone before\:\\r\\n; Abhishek Reddy's snake\: http\://www.plt1.com/1070/even-smaller-snake/\\r\\n; Mark Volkmann's snake\: http\://www.ociweb.com/mark/programming/ClojureSnake.html \\r\\n\\r\\n; The START\:/END\: pairs are production artifacts for the book and not \\r\\n; part of normal Clojure style\\r\\n\\r\\n(ns examples.snake\\r\\n  (\:import (java.awt Color Dimension) \\r\\n\\t   (javax.swing JPanel JFrame Timer JOptionPane)\\r\\n           (java.awt.event ActionListener KeyListener))\\r\\n  (\:use examples.import-static))\\r\\n(import-static java.awt.event.KeyEvent VK_LEFT VK_RIGHT VK_UP VK_DOWN)\\r\\n\\r\\n; ----------------------------------------------------------\\r\\n; functional model\\r\\n; ----------------------------------------------------------\\r\\n; START\: constants\\r\\n(def width 75)\\r\\n(def height 50)\\r\\n(def point-size 10)\\r\\n(def turn-millis 75)\\r\\n(def win-length 5)\\r\\n(def dirs { VK_LEFT  [-1  0] \\r\\n            VK_RIGHT [ 1  0]\\r\\n            VK_UP    [ 0 -1] \\r\\n\\t    VK_DOWN  [ 0  1]})\\r\\n; END\: constants\\r\\n\\r\\n; START\: board math\\r\\n(defn add-points [& pts] \\r\\n  (vec (apply map + pts)))\\r\\n\\r\\n(defn point-to-screen-rect [pt] \\r\\n  (map \#(* point-size %) \\r\\n       [(pt 0) (pt 1) 1 1]))\\r\\n; END\: board math\\r\\n\\r\\n; START\: apple\\r\\n(defn create-apple [] \\r\\n  {\:location [(rand-int width) (rand-int height)]\\r\\n   \:color (Color. 210 50 90)\\r\\n   \:type \:apple}) \\r\\n; END\: apple\\r\\n\\r\\n; START\: snake\\r\\n(defn create-snake []\\r\\n  {\:body (list [1 1]) \\r\\n   \:dir [1 0]\\r\\n   \:type \:snake\\r\\n   \:color (Color. 15 160 70)})\\r\\n; END\: snake\\r\\n\\r\\n; START\: move\\r\\n(defn move [{\:keys [body dir] \:as snake} & grow]\\r\\n  (assoc snake \:body (cons (add-points (first body) dir) \\r\\n\\t\\t\\t   (if grow body (butlast body)))))\\r\\n; END\: move\\r\\n\\r\\n; START\: turn\\r\\n(defn turn [snake newdir] \\r\\n  (assoc snake \:dir newdir))\\r\\n; END\: turn\\r\\n\\r\\n; START\: win?\\r\\n(defn win? [{body \:body}]\\r\\n  (>\= (count body) win-length))\\r\\n; END\: win?\\r\\n\\r\\n; START\: lose?\\r\\n(defn head-overlaps-body? [{[head & body] \:body}]\\r\\n  (contains? (set body) head))\\r\\n\\r\\n(def lose? head-overlaps-body?)\\r\\n; END\: lose?\\r\\n\\r\\n; START\: eats?\\r\\n(defn eats? [{[snake-head] \:body} {apple \:location}]\\r\\n   (\= snake-head apple))\\r\\n; END\: eats?\\r\\n\\r\\n; ----------------------------------------------------------\\r\\n; mutable model\\r\\n; ----------------------------------------------------------\\r\\n; START\: update-positions\\r\\n(defn update-positions [snake apple]\\r\\n  (dosync\\r\\n   (if (eats? @snake @apple)\\r\\n     (do (ref-set apple (create-apple))\\r\\n\\t (alter snake move \:grow))\\r\\n     (alter snake move)))\\r\\n  nil)\\r\\n; END\: update-positions\\r\\n\\r\\n; START\: update-direction\\r\\n(defn update-direction [snake newdir]\\r\\n  (when newdir (dosync (alter snake turn newdir))))\\r\\n; END\: update-direction\\r\\n\\r\\n; START\: reset-game\\r\\n(defn reset-game [snake apple]\\r\\n  (dosync (ref-set apple (create-apple))\\r\\n\\t  (ref-set snake (create-snake)))\\r\\n  nil)\\r\\n; END\: reset-game\\r\\n\\r\\n; ----------------------------------------------------------\\r\\n; gui\\r\\n; ----------------------------------------------------------\\r\\n; START\: fill-point\\r\\n(defn fill-point [g pt color] \\r\\n  (let [[x y width height] (point-to-screen-rect pt)]\\r\\n    (.setColor g color) \\r\\n    (.fillRect g x y width height)))\\r\\n; END\: fill-point\\r\\n\\r\\n; START\: paint\\r\\n(defmulti paint (fn [g object & _] (\:type object)))\\r\\n\\r\\n(defmethod paint \:apple [g {\:keys [location color]}] ; <label id\=\\"code.paint.apple\\"/>\\r\\n  (fill-point g location color))\\r\\n\\r\\n(defmethod paint \:snake [g {\:keys [body color]}] ; <label id\=\\"code.paint.snake\\"/>\\r\\n  (doseq [point body]\\r\\n    (fill-point g point color)))\\r\\n; END\: paint\\r\\n\\r\\n; START\: game-panel\\r\\n(defn game-panel [frame snake apple]\\r\\n  (proxy [JPanel ActionListener KeyListener] []\\r\\n    (paintComponent [g] ; <label id\=\\"code.game-panel.paintComponent\\"/>\\r\\n      (proxy-super paintComponent g)\\r\\n      (paint g @snake)\\r\\n      (paint g @apple))\\r\\n    (actionPerformed [e] ; <label id\=\\"code.game-panel.actionPerformed\\"/>\\r\\n      (update-positions snake apple)\\r\\n      (when (lose? @snake)\\r\\n\\t(reset-game snake apple)\\r\\n\\t(JOptionPane/showMessageDialog frame \\"You lose\!\\"))\\r\\n      (when (win? @snake)\\r\\n\\t(reset-game snake apple)\\r\\n\\t(JOptionPane/showMessageDialog frame \\"You win\!\\"))\\r\\n      (.repaint this))\\r\\n    (keyPressed [e] ; <label id\=\\"code.game-panel.keyPressed\\"/>\\r\\n      (update-direction snake (dirs (.getKeyCode e))))\\r\\n    (getPreferredSize [] \\r\\n      (Dimension. (* (inc width) point-size) \\r\\n\\t\\t  (* (inc height) point-size)))\\r\\n    (keyReleased [e])\\r\\n    (keyTyped [e])))\\r\\n; END\: game-panel\\r\\n\\r\\n; START\: game\\r\\n(defn game [] \\r\\n  (let [snake (ref (create-snake)) ; <label id\=\\"code.game.let\\"/>\\r\\n\\tapple (ref (create-apple))\\r\\n\\tframe (JFrame. \\"Snake\\")\\r\\n\\tpanel (game-panel frame snake apple)\\r\\n\\ttimer (Timer. turn-millis panel)]\\r\\n    (doto panel ; <label id\=\\"code.game.panel\\"/>\\r\\n      (.setFocusable true)\\r\\n      (.addKeyListener panel))\\r\\n    (doto frame ; <label id\=\\"code.game.frame\\"/>\\r\\n      (.add panel)\\r\\n      (.pack)\\r\\n      (.setVisible true))\\r\\n    (.start timer) ; <label id\=\\"code.game.timer\\"/>\\r\\n    [snake, apple, timer])) ; <label id\=\\"code.game.return\\"/>\\r\\n; END\: game" "(game)" "(ns model.core\\r\\n  (\:use [anglican core runtime emit stat]))" "(sample (categorical (list ('green (/ 1 3)) ('blue (/ 1 3)) ('red (/ 1 3)))))" "(sample* (categorical (list ('green (/ 1 3)) ('blue (/ 1 3)) ('red (/ 1 3)))))" "(sample* (categorical (list (4 (/ 1 3)) (3 (/ 1 3)) (2 (/ 1 3)))))" "(sample* (discrete (list (/ 1 3) (/ 1 3) (/ 1 3))))" "(doquery \:lmh (sample* (discrete (list (/ 1 3) (/ 1 3) (/ 1 3)))) nil)" "(doquery \:lmh (sample (discrete (list (/ 1 3) (/ 1 3) (/ 1 3)))) nil)" "(ns model.core\\r\\n  (\:use [anglican core runtime emit stat]))" "(doquery \:lmh (sample (discrete (list (/ 1 3) (/ 1 3) (/ 1 3)))) nil)" "(doquery \:lmh (defquery test [] (sample (discrete (list (/ 1 3) (/ 1 3) (/ 1 3))))) nil)" "(doquery \:lmh (sample (discrete (list (/ 1 3) (/ 1 3) (/ 1 3)))) nil)" "(ns model.test\\r\\n  (\:use [anglican core runtime emit stat]))" "(first (doquery \:lmh change-color red))" "(first (doquery \:lmh change-color 'red))" "(disj [0 1 2 3] 0)" "(peek [1 2 3])" "(rest [1 2 3])" "(conj [1 2] [3 5])" "(filter (fn [x y] (\= x y)) [0 1 2 3] 1)" "(filter (fn [x] (\= x y)) [0 1 2 3] 1)" "(filter (fn [x y] (\= x y)) [0 1 2 3] 1)" "(filter (fn [x y] (\= x y)) [0 1 2 3] 1 1)" "(filter (fn [x y] (\= x y)) [0 1 2 3])" "(remove \#(\= x 1) [1 0 3])" "(remove (fn [x] (\= x 1)) [1 0 3])" "(remove (fn [x] (\= x 2)) [1 0 3])" "(remove (fn [x] (\= x 3)) [1 0 3])" "(get-color-distribution 0)" "(sample* (discrete (get-color-distribution color)))" "(sample* (discrete (get-color-distribution 0)))" "(get-color-distribution 0)" "(remove (fn [x] (\= x 1)) [0 1 2 3])" "(first [1 2 3])" "(conj 1 [1 2 3])" "(conj [1 2 3] 1)" "(pop (1 2 2))" "(pop (list 1 2 2))" "(remove \#(1) (list 1 2 3 4))" "(remove \#(\:1) (list \:1 \:2 \:3 \:4))" "(remove \#{\:foo} (list \:foo \:bar))" "(remove \#{\:1} (list \:1 \:2))" "(remove \#{1} (list 1 2))" "(remove \#{1} [0 1 2 3])" "(find-ns sample)" "(find-ns sample*)" "(ns model.core\\r\\n  (\:use [anglican core runtime emit stat]))"]
eclipse.preferences.version=1
